---
layout: post
title: Java中的一些零碎点 
category: Java
tag: [Java]
---
这篇文章主要记录一些Java学习中遇到的需要留心的知识点。

- **基本变量**  
基本变量不用new创建变量，而是创建一个并非是引用的“自动变量”。存储在堆栈中，比存储在堆中的对象速度更快。  
基本变量共有八个，分别是boolean,char,byte,short,int,long,float,double。  
特别需要注意的是：String不是基本变量，而是引用变量。  
  
- **函数实现数组元素交换**  
在C语言中，要用函数实现数组元素的交换需要引入指针或引用，在Java中没有那么麻烦，直接将数组传入即可。  
  
- **对象作用域问题**  
	String s = new String();  
在上面这行代码中，s指向的String对象会一直存在（不需要时会被垃圾回收），而引用s在其作用域结束后失去作用。  
  
- **Java中的命名规范**  
包名采用反转域名+模块名，全小写。类名首字母大写，其他采用驼峰式命名法。  
  
- **static**  
static方法可以不通过对象而直接使用方法名（或用类名）调用。  
static属性内存共同占有，使用不同的对象调用更改static属性都会引起属性值的改变。  
  
- **别名问题**  
假设有属性  
	int num=0；  
当用两个对象a，b分别调用num时，实际上这两个对象所调用的num是独立的。但当做以下操作
	a=b；
即将b引用的指向传递给了a引用，此时a,b均指向同一个对象，此时再做
	a.num=10;
则b引用下的num的值也变为10。  
  
- **equals与==**  
对于基本类型，比较“值”可以直接用“==”；在比较对象时，使用“==”比较的是引用，即使两个对象的属性是相同的，只要是不同的引用，返回的就是false。  
equals方法并不适用于基本类型，equals的默认行为也是比较引用，因此若想在自己的class中实现对象的属性的比较，需要对equals方法进行重写。  
  
- **位操作符与逻辑操作符**  
位操作符（&amp;，|）是将数转换为二进制，对每一位二进制数进行比较，同为1不同为0；  
逻辑操作符（&amp;&amp;，||）返回的是boolear类型，不一定会操作到底，如进行“&amp;&amp;”操作时，若前面已经有“假”出现，直接返回
false，停止比较。这种现象成为“短路现象”  
  
- **移位符**  
只能用于整型的二进制，左移位操作符（&lt;&lt;）在低位补0；  
有符号右移位（&gt;&gt;）：若为正，高位补0；若为负，高位补1；  
无符号右移位：(&lt;&lt;&lt;):高位补0；  
对于char、byte、short等类型数据，会先转换成int类型（实际上只要类型比int小都会转换成int），得到的结果也是一个int类型，且只有数值右端第五位才有用，这是因为2^5=32=int位数。由于被转换成int类型，移位后截断赋值回去，可能会产生错误数值。  
对于Long，结果是Long，只会采用右端低六位。  
  
- **类型转换的截断**  
7.9转换成int类型的结果是7而不是8，如果想要得到8，必须调用Math类中的round方法。 
  
- **初始化顺序**  
  在定义对象的地方进行初始化，意味着它们总是能够在构造器调用它们之前被初始化。定义的执行先于构造器。  

- **组合与继承**  
组合是在新类中产生现有类的对象，相当于将多个类的功能拿过来用，组合成一个新类。  
继承是在父类的基础上进行扩展。它不仅能实现父类的功能，还有一些新的功能。

- **多个类的执行**  
当一个java文件中有多个类时，只能存在一个public修饰的class，并且运行时仅默认运行public修饰的class。事实上这个public修饰的 class是对外访问的一个接口，若要调用其他class，在public的main中调用`类名.main(args)`即可。或者使用命令行调用。  

- **初始化基类**  
当创建一个子类对象时，其父类的一个子对象也被创建并包含在了这个子类对象中。子类对象的构造器在调用之前会先调用父类的构造器。如果没有手动定义构造器，其默认构造器会自动调用，若已经手动创建或者为有参构造器，需要手动的在子类构造器中使用`super(...)`来调用。初始化的顺序为父类构造器-按照声明顺序初始化成员变量-子类构造器。需要注意的是，此时父类构造器如果调用某个方法，这个方法在子类已经被覆盖，则调用的是子类的方法。但由于初始化的顺序问题，子类方法中的成员还没有被初始化，这就会导致一些意外的错误。     

- **继承中的重载**  
当父类的某个方法多次被重载，若在子类中改变此方法，没有添加`@Override`关键字时，其重载效果仍存在。 

- **抽象类与接口**  

<a href="http://www.360doc.com/content/10/0525/16/1039473_29458325.shtml">抽象类与接口</a>  

- **多态中的动态绑定**  
父类的引用接受父类及子类的对象，当子类引用向上转型为父类引用时，我们得到的是一个父类引用。当子类对父类的某个方法进行了覆盖写后，使用这个向上转型后的引用调用这个方法时，调用的仍然是子类自己的方法（这个方法不能是private的，因为private属于final，同样静态方法也不适用。静态方法时父类引用调用的是父类的方法，非静态的是子类的）。这是由于动态绑定的效果。java中除了static方法和final方法默认都进行动态绑定。  

- **协变返回类型**  
子类的返回值类型可以是同属于一个父类的其他子类的类型  

- **向下转型**  
`Super super = new Super();`
`Super sub = new Sub();`
`(Sub)super;`异常
`(Sub) sub;`通过  



