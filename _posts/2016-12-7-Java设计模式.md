---
layout: post
title: Java设计模式
category: java
tag: java
---

这篇文章主要记录了一些java设计模式  


***一、设计原则***  

**1、单一职责原则**  

一个类，只有一个引起它变化的原因。应该只有一个职责。每一个职责都是变化的一个轴线，如果一个类有一个以上的职责，这些职责就耦合在了一起。这会导致脆弱的设计。当一个职责发生变化时，可能会影响其它的职责。另外，多个职责耦合在一起，会影响复用性。例如：要实现逻辑和界面的分离。  

**2、开闭原则（Open Close Principle）**  

开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。  

**3、里氏代换原则（Liskov Substitution Principle）**  

里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。   里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。  

**4、依赖倒转原则（Dependence Inversion Principle）**  

所谓依赖倒置原则（Dependence Inversion Principle）就是要依赖于抽象，不要依赖于具体。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。  

实现开闭原则的关键是抽象化，并且从抽象化导出具体化实现，如果说开闭原则是面向对象设计的目标的话，那么依赖倒转原则就是面向对象设计的主要手段。   

**5、接口隔离原则（Interface Segregation Principle）**  

这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。  

**6、合成复用原则（Composite Reuse Principle）**  

合成复用原则就是指在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用其已有功能的目的。简言之：要尽量使用组合/聚合关系，少用继承。  

**7、迪米特法则（最少知道原则）（Demeter Principle）**  

为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。也就是说一个软件实体应当尽可能少的与其他实体发生相互作用。这样，当一个模块修改时，就会尽量少的影响其他的模块，扩展会相对容易，这是对软件实体之间通信的限制，它要求限制软件实体之间通信的宽度和深度。  

***二、模式介绍***  
**单例模式**  
单例模式保证了某个对象只有一个实例，对于某些大型系统，频繁创建对象对系统压力很大，产生的开销也很大，使用单例模式可以很好的降低开销，也省去了频繁的new一个新对象，节省内存。同时，创建多个实例代表允许多个线程运行，在某些系统中是不允许的。  
单例模式分两种方法：懒汉/饿汉  
饿汉模式：  
- 将类的构造器私有化（private），防止外部实例化对象  
- 在类内部自身实例化一个对象，唯一且私有（private static）  
- 提供一个公共静态的获取实例的方法（public static），用来获取这个唯一的实例  
懒汉模式：  
- 将类的构造器私有化（private），禁止外部实例化对象  
- 声明（仅声明）一个唯一的实例，静态私有（private static）
- 提供一个公共静态的获取实例的方法（public static），先判断这个唯一实例是否为空，不为空则实例化；否则直接返回  
懒汉和饿汉的比较：  
懒汉模式只有调用获取对象的实例方法时才会实例化对象，加载速度快，但运行时获取对象速度慢，线程不安全。  
饿汉模式在加载类时，改唯一对象实例就已经产生，无论是否需要。加载速度慢，但运行时获取对象速度快，线程安全。  

**工厂模式**  
工厂用来实现创建对象的细节，当用户需要一个对象时，只需要告诉工厂需要那个对象，工厂就会返回一个对象给用户使用，具体的创建对象的细节全部封装到工厂中。  
假设有A包和B包，A包要调用B包的代码，B包向A包提供一个C接口。B包中实现了C接口的类有100个，这100个类的构造器各不相同。如果A要调用B采用NEW的方法，将面临在100个构造器中选择的难题，这是不现实的。A可以通过工厂，向工厂传递一个参数，工厂内部在这100个类中选择符合这个参数的对象，将其返回给A。  

工厂分简单工厂模式、工厂方法模式、抽象工厂模式三种  
简单工厂模式：只有一个工厂，将new对象的过程封装起来，通过传进来的参数返回不同的对象。这种方法违反了开闭原则，当新增加一种对象时，工厂方法代码同样也需要进行改变。  
工厂方法模式：有多个具体工厂继承基类抽象工厂，每个具体工厂负责某一个对象的创建，这样在增加新的对象种类时，只需要再新建一个对应的工厂即可，符合开闭原则。  
抽象工厂模式：工厂方法模式的扩展，工厂方法中的产品只有一个，但抽象工厂中可以有多个，构成一个家族。  

**代理模式**  
代理是让某些类代替其他类做一些事，如可以采用代理的方式，在不改变A代码的情况下，用B实现A并做出一些改变。  
代理分静态代理和动态代理。  
静态代理是代理前就知道具体的信息，双方采用固定的端口和网络。  
代理可以传递，如果采用继承的方法会很冗杂，最好采用聚合的方式来进行代理传递。  

<pre>

public interface Moveable {
	void move();
}
</pre>
<pre>
public class Car implements Moveable {
	@Override
	public void move() {
		//开车
		try {
			Thread.sleep(new Random().nextInt(1000));
			System.out.println("开车中....");
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
}
</pre>
<pre>
public class CarLogProxy implements Moveable {

	public CarLogProxy(Moveable m) {
		super();
		this.m = m;
	}
	private Moveable m;
	
	@Override
	public void move() {
		System.out.println("日志开始....");
		m.move();
		System.out.println("日志结束....");
	}
}
</pre>
<pre>
public class CarTimeProxy implements Moveable {

	public CarTimeProxy(Moveable m) {
		super();
		this.m = m;
	}

	private Moveable m;
	
	@Override
	public void move() {
		long starttime = System.currentTimeMillis();
		System.out.println("开始行驶....");
		m.move();
		long endtime = System.currentTimeMillis();
		System.out.println("结束行驶....  行驶时间 
				+ (endtime - starttime)" + "毫秒");
	}

}
</pre>
<pre>
public class Client {

	/**
	 * 测试类
	 */
	public static void main(String[] args) {
		Car car = new Car();
		CarLogProxy clp = new CarLogProxy(car);
		CarTimeProxy ctp = new CarTimeProxy(clp);
		ctp.move();
		/*
		这里是代理传递。CarLogProxy() 和 CarTimeProxy()中的moveable m都是指向这里的 new Car()的引用
		clp中的m.move()是Car中的move(),ctp中的move()是clp中的move();
		按照这种传递式运行。
		*/
	}

}
</pre>
